#' Plots phylogenetic breakdown
#' 
#' This function generates a file, plotting the phylogenetic breakdown
#' of each sample, using taxonomical data from mothur.
#'
#' @param meta.frame A data frame containing all data. Two columns must be titled 'adiv' and
#' 'nseqs' and must contain the alpha diversity values and number of sequences respectively. All
#' other information be metadata or categorical/continuous variables that describe the samples.
#' @param data.types A list containing text indicators of each meta.frame column data type
#' in order. Input text for each list element are 'cat', 'cont', and 'meta'.
#' @param tax.key Taxonomical key table created from file generated by mothur
#' @param tax.data Taxonomical data table created from file generated by mothur
#' @param min.stack.proportion Decimal value dictating minimum proprtion of a clade for it to
#' receive its own stack on the final plot.
#'
#' @return No output is returned. Graph file generated: "TaxonomicComposition.pdf"
#'
#' @keywords keywords
#'
#' @export
#' 
#' @examples
#' meta.frame <- read.table("IECG57L01.graphics_data.txt", skip=1, header=TRUE, stringsAsFactors=FALSE)
#' data.types <- strsplit(readLines("IECG57L01.graphics_data.txt")[1], '\t')[[1]]
#' tax.key <- read.table('IECG57L01.final.pick.tx.1.cons.taxonomy', header = TRUE, stringsAsFactors = FALSE)
#' tax.data <- read.table('IECG57L01.final.pick.tx.shared', header = TRUE, stringsAsFactors = FALSE)
#' phylo(meta.frame, data.types, tax.key, tax.data, min.stack.proportion = 0.014)
phylo <- function(meta.frame, data.types, tax.key, tax.data, min.stack.proportion = 0.014)
{
  library('reshape2')
  library('scales')
  library('ggplot2')
    #threshold proportions for each level of classification are set here
    thresh.phyla <- min.stack.proportion
    thresh.classes <- min.stack.proportion
    thresh.orders <- min.stack.proportion
    thresh.families <- min.stack.proportion
    thresh.genera <- min.stack.proportion

    pdf('TaxonomicComposition.pdf')

    #copy of tax key that will be formatted
    key.frame <- tax.key

    #formatting key.frame and parsing everything nicely
    tmp <- strsplit(as.character(key.frame$Taxonomy), ';')
    key.frame$Taxonomy <- NULL

    key.frame$kingdom <- sapply(tmp, `[`, 1)
    key.frame$kingdomScore <- as.numeric(sapply(strsplit(gsub(')', '', key.frame$kingdom), '(', fixed = TRUE), `[`, 2))
    key.frame$kingdom <- sapply(strsplit(key.frame$kingdom, '(', fixed = TRUE), `[`, 1)

    key.frame$phylum <- gsub('"', '', sapply(tmp, `[`, 2))
    key.frame$phylumScore <- as.numeric(sapply(strsplit(gsub(')', '', key.frame$phylum), '(', fixed = TRUE), `[`, 2))
    key.frame$phylum <- sapply(strsplit(key.frame$phylum, '(', fixed = TRUE), `[`, 1)

    key.frame$class <- gsub('"', '', sapply(tmp, `[`, 3))
    key.frame$classScore <- as.numeric(sapply(strsplit(gsub(')', '', key.frame$class), '(', fixed = TRUE), `[`, 2))
    key.frame$class <- sapply(strsplit(key.frame$class, '(', fixed = TRUE), `[`, 1)

    key.frame$order <- gsub('"', '', sapply(tmp, `[`, 4))
    key.frame$orderScore <- as.numeric(sapply(strsplit(gsub(')', '', key.frame$order), '(', fixed = TRUE), `[`, 2))
    key.frame$order <- sapply(strsplit(key.frame$order, '(', fixed = TRUE), `[`, 1)

    key.frame$family <- gsub('"', '', sapply(tmp, `[`, 5))
    key.frame$familyScore <- as.numeric(sapply(strsplit(gsub(')', '', key.frame$family), '(', fixed = TRUE), `[`, 2))
    key.frame$family <- sapply(strsplit(key.frame$family, '(', fixed = TRUE), `[`, 1)

    key.frame$genus <- gsub('"', '', sapply(tmp, `[`, 6))
    key.frame$genusScore <- as.numeric(sapply(strsplit(gsub(')', '', key.frame$genus), '(', fixed = TRUE), `[`, 2))
    key.frame$genus <- sapply(strsplit(key.frame$genus, '(', fixed = TRUE), `[`, 1)

    #TREE NODING SYSTEM
    #this is the list of unique nodes
    unique.nodes <- vector()
    #key.frame$node column is the tax name that the OTU is assigned to
    #this makes it such that we can refer to it later on when finding the OTUs for each unique tax name/node
    key.frame$node <- NA
    tree <- list()
    total.size <- sum(key.frame$Size)
    phyla <- unique(key.frame$phylum)

    #The following nested mess goes through each level of classification
    #Checks if each node is significant enough
    #And continues noding
    #The tree list is used as a condition in the many if else statements
    #These if else statements determine what to do with the node (continue noding, add as node, etx.)
    #every time a node is finalized, it is added to unique.nodes
    #THIS IS WHERE THE MOST BUGS, IF ANY, WOULD BE
    for(phylum in phyla)
    {
        phyla.size <- sum(key.frame$Size[which(key.frame$phylum == phylum)])
        if(phyla.size/total.size > thresh.phyla & phylum != 'unclassified')
        {
            tree[[phylum]] <- list(pct = phyla.size/total.size)
            classes <- unique(key.frame$class[key.frame$phylum == phylum])
            for(class in classes)
            {
                classes.size <- sum(key.frame$Size[which(key.frame$class==class)])
                if(classes.size/total.size > thresh.classes & class != 'unclassified')
                {
                    tree[[phylum]][[class]] <- list(pct = classes.size/total.size)
                    orders <- unique(key.frame$order[key.frame$class==class])
                    for(order in orders)
                    {
                        orders.size <- sum(key.frame$Size[which(key.frame$order==order)])
                        if(orders.size/total.size > thresh.orders & order != 'unclassified')
                        {
                            tree[[phylum]][[class]][[order]] <- list(pct = orders.size/total.size)
                            families <- unique(key.frame$family[key.frame$order==order])
                            for(family in families)
                            {
                                families.size <- sum(key.frame$Size[which(key.frame$family==family)])
                                if(families.size/total.size > thresh.families & family != 'unclassified')
                                {
                                    tree[[phylum]][[class]][[order]][[family]] <- list(pct = families.size/total.size)
                                    genera <- unique(key.frame$genus[key.frame$family==family])
                                    for(genus in genera)
                                    {
                                        genera.size <- sum(key.frame$Size[which(key.frame$genus==genus)])
                                        if(genera.size/total.size > thresh.genera & genus != 'unclassified')
                                        {
                                            tree[[phylum]][[class]][[order]][[family]][[genus]] <- list(pct = genera.size/total.size)
                                            key.frame$node[key.frame$genus == genus] <- paste(phylum, ' (', genus, ')', sep = '')
                                            unique.nodes <- append(unique.nodes, paste(phylum, ' (', genus, ')', sep = ''))
                                        }
                                        else
                                        {
                                            key.frame$node[key.frame$family==family & key.frame$genus == genus] <- paste(phylum, '(other)')
                                            unique.nodes <- append(unique.nodes, paste(phylum, '(other)'))
                                        }
                                    }
                                    if(length(tree[[phylum]][[class]][[order]][[family]]) == 1)
                                    {
                                        key.frame$node[key.frame$family == family] <- paste(phylum, ' (', family, ')', sep = '')
                                        unique.nodes <- append(unique.nodes, paste(phylum, ' (', family, ')', sep = ''))
                                    }
                                }
                                else
                                {
                                    key.frame$node[key.frame$order == order & key.frame$family == family] <- paste(phylum, '(other)')
                                    unique.nodes <- append(unique.nodes, paste(phylum, '(other)'))
                                }
                            }
                            if(length(tree[[phylum]][[class]][[order]]) == 1)
                            {
                                key.frame$node[key.frame$order == order] <- paste(phylum, ' (', order, ')', sep = '')
                                unique.nodes <- append(unique.nodes, paste(phylum, ' (', order, ')', sep = ''))
                            }
                        }
                        else
                        {
                            key.frame$node[key.frame$phylum == phylum & key.frame$order == order] <- paste(phylum, '(other)')
                            unique.nodes <- append(unique.nodes, paste(phylum, '(other)'))
                        }
                    }
                    if(length(tree[[phylum]][[class]]) == 1)
                    {
                        key.frame$node[key.frame$class == class] <- paste(phylum, ' (', class, ')', sep = '')
                        unique.nodes <- append(unique.nodes, paste(phylum, ' (', class, ')', sep = ''))
                    }
                }
                else
                {
                    key.frame$node[key.frame$phylum == phylum & key.frame$class == class] <- paste(phylum, '(other)')
                    unique.nodes <- append(unique.nodes, paste(phylum, '(other)'))
                }
            }
            if(length(tree[[phylum]]) == 1)
            {
                key.frame$node[key.frame$phylum == phylum] <- phylum
                unique.nodes <- append(unique.nodes, phylum)
            }
        }
        else
        {
            key.frame$node[key.frame$phylum == phylum] <- 'other'
        }
    }
    #since unique.nodes has duplicates, unique would remove the dupicates
    unique.nodes <- unique(unique.nodes)
    #since some of the added nodes may have been removed at other parts of the tree noding system
    #this next line intersects it with the actual unique list
    #remember, the purpose of this unique.nodes list is only to keep the order of noding
    #instead, one would otherwise go thru and sort the unique list with loops afterwards
    unique.nodes <- intersect(unique.nodes, unique(key.frame$node))
    #this moves all others to the end of their group
    i <- 1
    while(i <= length(unique.nodes))
    {
        if(length(grep('\\(other\\)', unique.nodes[i])) == 1)
        {
            tmp.other <- unique.nodes[i]
            tmp.phyla <- sub(' \\(other\\)', '', tmp.other)
            j <- i
            while(length(grep(tmp.phyla, unique.nodes[j])) == 1)
            {
                j <- j + 1
            }
            tmp.last <- unique.nodes[j-1]
            unique.nodes[j-1] <- tmp.other
            unique.nodes[i] <- tmp.last
            i <- j
        }
        else
        {
            i <- i + 1
        }
    }
    nodes <- key.frame$node
    unique.nodes <- append(unique.nodes, 'other')
    #FOR EACH CATEGORY
    for(i in 1:length(data.types))
    {
        column <- meta.frame[,i]
        if (data.types[i] == 'cat') #grabs categorical info rows
        {
            fdata <- data.frame(matrix(ncol=(length(unique.nodes)+3), nrow=nrow(meta.frame)), stringsAsFactors = FALSE)
            names(fdata) <- append(c('sample','group','nseqs'),unique.nodes)
            str(fdata)
            frow <-0

            groups <- unique(column) #grabs different types of the category
            #FOR EACH TYPE IN CATEGORY
            for(j in 1:length(groups))
            {
                index <- which(meta.frame[,i] == groups[j])
                #FOR EACH SAMPLE IN CATEGORY TYPE
                for(k in 1:length(index))
                {
                    row <- which(tax.data$Group == meta.frame$Barcode[index[k]])
                    nseqs <- meta.frame$nseqs[index[k]]
                    frow <- frow+1
                    fdata[frow,1] <- meta.frame$Barcode[index[k]]
                    fdata[frow,2] <- groups[j]
                    fdata[frow,3] <- nseqs

                    total<-0
                    for(l in 4:length(tax.data))
                    {
                        total <- total + tax.data[row,l]
                    }
                    #FOR EACH UNIQUE NODE
                    for(l in 1:length(unique.nodes))
                    {
                        OTU.key.index <- which(nodes == unique.nodes[l])
                        OTUs <- key.frame$OTU[OTU.key.index]

                        # FIX FOR LINE 262, WHICH PREVIOUSLY THREW AN ERROR
			for(s in 1:length(OTUs))
			{
                          if(nchar(colnames(tax.data)[4]) == 6)
                            {
                              if(nchar(OTUs[s]) == 1)
                                {
                                  OTUs[s] <- paste("Otu00", as.character(OTUs[s]), sep = "")
                                }
                              else if(nchar(OTUs[s]) == 2)
                                {
                                  OTUs[s] <- paste("Otu0", as.character(OTUs[s]), sep = "")
                                }
                              else if(nchar(OTUs[s]) == 3)
                                {
                                  OTUs[s] <- paste("Otu", as.character(OTUs[s]), sep = "")
                                }
                            }
                          if(nchar(colnames(tax.data)[4]) == 5)
                            {
                              if(nchar(OTUs[s]) == 1)
                                {
                                  OTUs[s] <- paste("Otu0", as.character(OTUs[s]), sep = "")
                                }
                              else if(nchar(OTUs[s]) == 2)
                                {
                                  OTUs[s] <- paste("Otu", as.character(OTUs[s]), sep = "")
                                }
                            }
                          if(nchar(colnames(tax.data)[4]) == 4)
                            {
                                  OTUs[s] <- paste("Otu", as.character(OTUs[s]), sep = "")
                            }
			}
                        OTU.data.cols <- vector()
                        #GET COLUMNS OF OTUS OF SAME NODE
                        for(m in 1:length(OTUs))
                        {
                            OTU.data.cols <- append(OTU.data.cols, which(colnames(tax.data)==OTUs[m]))
                        }

                        #GET TOTAL NODE FREQUENCY FOR THIS SAMPLE
                        freq <- 0
                        for(m in 1:length(OTU.data.cols))
                        {
                            freq <- freq + tax.data[row,OTU.data.cols[m]]
                        }
                        fdata[frow,l+3] <- ((freq/total)*100)
                    }
                    #USED IN DEBUGGING ONLY - IGNORE THESE TMP VARIABLES
                    tmp1 <- meta.frame$Barcode[index[k]]
                    tmp2 <- groups[j]
                    tmp3 <- nseqs
                }
            }

            str(fdata)
            fdata <- fdata[with(fdata, order(nseqs)),]
            #adding xorder
            for(j in 1:nrow(fdata))
            {
                fdata$xorder[j] <- j
            }
            #PLOT WITH GGPLOT2
            fdata$nseqs <- factor(fdata$nseqs)
            fdata$xorder <- factor(fdata$xorder)
            ggfdata <- melt(fdata, id.var=c('group','nseqs','sample', 'xorder'), variable.name = 'Taxonomy')
            p <- ggplot(ggfdata, aes(x=xorder, y=value, fill = Taxonomy)) +
                 geom_bar(stat='identity') + facet_grid(~group, scales='free_x', space='free_x') + scale_y_continuous() +
                 labs(title=paste('Taxonomic Distribution - grouped by',colnames(meta.frame)[i])) +
                 ylab('Percentage') + xlab('(sorted within group by increasing number of sequences)') +
                 theme(axis.ticks.x = element_blank(), axis.text.x = element_blank()) + scale_x_discrete() +
                 scale_color_brewer()
            print(p)
          }
    }
    dev.off()
}

#meta.frame <- read.table('IECG57L01.graphics_data.txt', skip=1, header=TRUE, stringsAsFactors=FALSE)
#data.types <- strsplit(readLines('IECG57L01.graphics_data.txt')[1], '\t')[[1]]
#tax.key <- read.table('IECG57L01.final.pick.tx.1.cons.taxonomy', header = TRUE, stringsAsFactors = FALSE)
#tax.data <- read.table('IECG57L01.final.pick.tx.shared', header = TRUE, stringsAsFactors = FALSE)
#phylo(meta.frame, data.types, tax.key, tax.data, min.stack.proportion = 0.014)
